from datetime import datetime
from uuid import uuid4
import json
from openai import OpenAI
from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    EndSessionContent,
    TextContent,
    chat_protocol_spec,
)

# -------------------------
# PLANNER CONFIGURATION
# -------------------------
AGENT_NAME = "WanderLink_Planner"
API_KEY = "sk_7aa8a96be59b426695dcd1a2ee00e5807c2903f9c43b4f1c8d84d8fb52ac62a4"

client = OpenAI(
    base_url="https://api.asi1.ai/v1",
    api_key=API_KEY,
)

agent = Agent(name=AGENT_NAME)

# Create protocol compatible with chat protocol spec
protocol = Protocol(spec=chat_protocol_spec)

# Storage keys
GROUPS_KEY = "active_groups"
GROUP_CHATS_KEY = "group_chats"

# -------------------------
# HANDLER: Receive Group Data from MatchMaker
# -------------------------
@protocol.on_message(ChatMessage)
async def handle_group_creation(ctx: Context, sender: str, msg: ChatMessage):
    """
    Receive matched group data from MatchMaker,
    create group chat, and send itinerary to all members.
    """
    # Send acknowledgement
    await ctx.send(
        sender,
        ChatAcknowledgement(
            timestamp=datetime.now(), 
            acknowledged_msg_id=msg.msg_id
        ),
    )

    # Extract message text
    text = ""
    for item in msg.content:
        if isinstance(item, TextContent):
            text += item.text.strip() + " "

    ctx.logger.info(f"📨 Received group data from MatchMaker")

    try:
        # Parse group data from MatchMaker
        group_data = json.loads(text)
        
        group_id = group_data.get("group_id")
        user_ids = group_data.get("user_ids", [])
        itinerary = group_data.get("itinerary", "")
        group_info = group_data.get("group_info", {})
        
        ctx.logger.info(f"👥 Creating group: {group_id}")
        ctx.logger.info(f"📍 Destination: {group_info.get('destination')}")
        ctx.logger.info(f"👤 Members: {len(user_ids)}")
        
        # Store group information
        groups = ctx.storage.get(GROUPS_KEY)
        if groups is None:
            groups = {}
        else:
            if isinstance(groups, str):
                groups = json.loads(groups)
        
        # Create group record
        groups[group_id] = {
            "created_at": datetime.utcnow().isoformat(),
            "members": user_ids,
            "destination": group_info.get("destination"),
            "travel_type": group_info.get("travel_type"),
            "members_count": len(user_ids),
            "itinerary_sent": False
        }
        ctx.storage.set(GROUPS_KEY, json.dumps(groups))
        
        # Initialize group chat storage
        group_chats = ctx.storage.get(GROUP_CHATS_KEY)
        if group_chats is None:
            group_chats = {}
        else:
            if isinstance(group_chats, str):
                group_chats = json.loads(group_chats)
        
        group_chats[group_id] = {
            "messages": [],
            "members": user_ids,
            "created_at": datetime.utcnow().isoformat()
        }
        ctx.storage.set(GROUP_CHATS_KEY, json.dumps(group_chats))
        
        ctx.logger.info(f"💬 Group chat initialized for group {group_id[:8]}")
        
        # Create welcome message with itinerary
        welcome_msg = f"""
🎉 **WANDERLINK GROUP FORMED!**

Welcome to your travel group! You've been matched with {len(user_ids) - 1} other traveler(s) with similar interests.

**Group ID:** {group_id[:8]}...
**Destination:** {group_info.get('destination', 'Unknown')}
**Travel Type:** {group_info.get('travel_type', 'Mixed')}
**Group Size:** {len(user_ids)} travelers

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 **YOUR COMBINED ITINERARY:**

{itinerary}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💬 **What's Next?**
- Start chatting with your group members
- Coordinate travel dates and bookings
- Share contact information
- Plan additional activities together

You can now send messages to this group chat! 🚀
"""
        
        # Send itinerary to all group members using ChatMessage
        ctx.logger.info(f"📤 Sending itinerary to {len(user_ids)} members...")
        
        for idx, user_id in enumerate(user_ids):
            try:
                await ctx.send(
                    user_id, 
                    ChatMessage(
                        timestamp=datetime.utcnow(),
                        msg_id=uuid4(),
                        content=[
                            TextContent(type="text", text=welcome_msg),
                            # Note: We don't use EndSessionContent here because 
                            # we want to keep the chat open for group messages
                        ]
                    )
                )
                ctx.logger.info(f"✉️  [{idx+1}/{len(user_ids)}] Sent to user: {user_id[:12]}...")
            except Exception as e:
                ctx.logger.error(f"❌ Failed to send to {user_id[:12]}: {e}")
        
        # Update group status
        groups[group_id]["itinerary_sent"] = True
        groups[group_id]["welcome_sent_at"] = datetime.utcnow().isoformat()
        ctx.storage.set(GROUPS_KEY, json.dumps(groups))
        
        # Store initial message in group chat history
        initial_msg = {
            "msg_id": str(uuid4()),
            "sender": "planner",
            "text": welcome_msg,
            "timestamp": datetime.utcnow().isoformat(),
            "type": "system"
        }
        group_chats[group_id]["messages"].append(initial_msg)
        ctx.storage.set(GROUP_CHATS_KEY, json.dumps(group_chats))
        
        ctx.logger.info(f"✅ Group {group_id[:8]} created successfully!")
        ctx.logger.info(f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")
        
    except json.JSONDecodeError as e:
        ctx.logger.error(f"❌ Invalid JSON received from MatchMaker")
        ctx.logger.exception(e)
    except Exception as e:
        ctx.logger.exception(f"❌ Error creating group: {e}")


# -------------------------
# HANDLER: Group Chat Messages
# -------------------------
@protocol.on_message(ChatMessage)
async def handle_group_message(ctx: Context, sender: str, msg: ChatMessage):
    """
    Handle messages sent within group chats.
    When a user sends a message, broadcast it to all group members.
    """
    # Check if this is a new message from a group member (not initial setup)
    if sender.startswith("agent1qdsd"):  # MatchMaker address - skip
        return
    
    # Extract message text
    text = ""
    for item in msg.content:
        if isinstance(item, TextContent):
            text += item.text.strip() + " "
    
    # Find which group this user belongs to
    groups = ctx.storage.get(GROUPS_KEY)
    if groups:
        if isinstance(groups, str):
            groups = json.loads(groups)
        
        user_group_id = None
        for group_id, group_data in groups.items():
            if sender in group_data.get("members", []):
                user_group_id = group_id
                break
        
        if user_group_id:
            ctx.logger.info(f"💬 Group message from {sender[:12]} in group {user_group_id[:8]}")
            
            # Store message in group chat
            group_chats = ctx.storage.get(GROUP_CHATS_KEY)
            if isinstance(group_chats, str):
                group_chats = json.loads(group_chats)
            
            if user_group_id in group_chats:
                new_msg = {
                    "msg_id": str(msg.msg_id),
                    "sender": sender,
                    "text": text,
                    "timestamp": datetime.utcnow().isoformat(),
                    "type": "user"
                }
                group_chats[user_group_id]["messages"].append(new_msg)
                ctx.storage.set(GROUP_CHATS_KEY, json.dumps(group_chats))
                
                # Broadcast to all other group members
                group_members = groups[user_group_id]["members"]
                sender_short = sender[:8] + "..."
                
                broadcast_msg = f"👤 {sender_short}: {text}"
                
                for member_id in group_members:
                    if member_id != sender:  # Don't send back to sender
                        try:
                            await ctx.send(
                                member_id,
                                ChatMessage(
                                    timestamp=datetime.utcnow(),
                                    msg_id=uuid4(),
                                    content=[
                                        TextContent(type="text", text=broadcast_msg)
                                    ]
                                )
                            )
                        except Exception as e:
                            ctx.logger.error(f"Failed to broadcast to {member_id[:12]}: {e}")
                
                ctx.logger.info(f"✅ Message broadcasted to {len(group_members)-1} members")


@protocol.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement):
    """
    Handle acknowledgements (read receipts).
    Can be used to implement delivery confirmation.
    """
    # Optional: Log read receipts
    ctx.logger.debug(f"📬 Acknowledgement from {sender[:12]} for msg {msg.acknowledged_msg_id}")
    pass


# -------------------------
# STARTUP LOGGING
# -------------------------
@agent.on_event("startup")
async def startup(ctx: Context):
    ctx.logger.info("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    ctx.logger.info("🗓️  WanderLink Planner Agent Started!")
    ctx.logger.info("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    ctx.logger.info(f"📬 Agent Address: {agent.address}")
    ctx.logger.info(f"💬 Chat Protocol: Enabled")
    ctx.logger.info(f"🤖 ASI-1 Integration: Active")
    ctx.logger.info("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    ctx.logger.info("✨ Ready to create travel groups!")
    ctx.logger.info("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n")


# -------------------------
# ATTACH PROTOCOL AND RUN
# -------------------------
agent.include(protocol, publish_manifest=True)