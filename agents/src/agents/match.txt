from datetime import datetime
from uuid import uuid4
import json
from openai import OpenAI
from uagents import Agent, Context, Protocol
from uagents_core.contrib.protocols.chat import (
    ChatAcknowledgement,
    ChatMessage,
    TextContent,
    chat_protocol_spec,
)

# -------------------------
# MATCHMAKER CONFIGURATION
# -------------------------
AGENT_NAME = "WanderLink_MatchMaker"
PLANNER_ADDRESS = "agent1q..." # Add your Planner agent address here
API_KEY = "sk_7aa8a96be59b426695dcd1a2ee00e5807c2903f9c43b4f1c8d84d8fb52ac62a4"

client = OpenAI(
    base_url="https://api.asi1.ai/v1",
    api_key=API_KEY,
)

agent = Agent(name=AGENT_NAME)
protocol = Protocol(spec=chat_protocol_spec)

MIN_GROUP_SIZE = 3
TRIP_POOL_KEY = "trip_pool"

# -------------------------
# HELPER FUNCTIONS
# -------------------------
def extract_duration_days(duration):
    """Extract number of days from duration, handling various formats"""
    if duration is None or duration == "":
        return 0
    if isinstance(duration, int):
        return duration
    if isinstance(duration, str):
        import re
        numbers = re.findall(r'\d+', duration)
        return int(numbers[0]) if numbers else 0
    return 0

def is_valid_trip(trip_data):
    """Check if trip has minimum required data"""
    try:
        prefs = trip_data.get("preferences", {})
        if not prefs.get("destination") or prefs.get("destination") == "":
            return False
        return True
    except:
        return False

def compute_similarity(t1, t2):
    """Compute similarity score between two trips (0.0 to 1.0)"""
    try:
        score = 0
        
        # Destination similarity (50% weight)
        dest1 = str(t1["preferences"].get("destination", "")).lower().strip()
        dest2 = str(t2["preferences"].get("destination", "")).lower().strip()
        if dest1 and dest2 and dest1 == dest2:
            score += 0.5
        
        # Travel type similarity (30% weight)
        type1 = str(t1["preferences"].get("travel_type", "")).lower().strip()
        type2 = str(t2["preferences"].get("travel_type", "")).lower().strip()
        if type1 and type2:
            keywords = ["beach", "adventure", "cultural", "relaxing", "romantic"]
            for keyword in keywords:
                if keyword in type1 and keyword in type2:
                    score += 0.3
                    break
        
        # Duration similarity (20% weight)
        d1 = extract_duration_days(t1["preferences"].get("duration"))
        d2 = extract_duration_days(t2["preferences"].get("duration"))
        
        if d1 > 0 and d2 > 0:
            diff = abs(d1 - d2)
            if diff <= 2:
                score += 0.2
            elif diff <= 4:
                score += 0.1
        
        return score
    except Exception as e:
        return 0.0

def greedy_swap_grouping(trips, threshold=0.5):
    """Group trips based on similarity threshold"""
    groups = []
    for trip in trips:
        matched = False
        for g in groups:
            if any(compute_similarity(trip, t) >= threshold for t in g):
                g.append(trip)
                matched = True
                break
        if not matched:
            groups.append([trip])
    return groups

# -------------------------
# HANDLER
# -------------------------
@protocol.on_message(ChatMessage)
async def handle_trip(ctx: Context, sender: str, msg: ChatMessage):
    """
    Receive trip data from TravelAgent, form groups, generate itinerary,
    and send to Planner Agent for group creation.
    """
    await ctx.send(sender, ChatAcknowledgement(
        timestamp=datetime.now(),
        acknowledged_msg_id=msg.msg_id,
    ))

    text = ""
    for item in msg.content:
        if isinstance(item, TextContent):
            text += item.text.strip() + " "

    ctx.logger.info(f"üì® Received trip proposal: {text}")

    try:
        trip_data = json.loads(text)
        
        if not is_valid_trip(trip_data):
            ctx.logger.warning(f"‚ö†Ô∏è  Invalid trip data received")
            return
        
        # Get existing trip pool
        trip_pool = ctx.storage.get(TRIP_POOL_KEY)
        if trip_pool is None:
            trip_pool = []
        else:
            if isinstance(trip_pool, str):
                trip_pool = json.loads(trip_pool)
        
        # Add new trip
        trip_pool.append(trip_data)
        ctx.storage.set(TRIP_POOL_KEY, json.dumps(trip_pool))
        
        ctx.logger.info(f"‚úì Stored trip. Total trips: {len(trip_pool)}")

        if len(trip_pool) < MIN_GROUP_SIZE:
            ctx.logger.info(f"‚è≥ Waiting for more travelers ({len(trip_pool)}/{MIN_GROUP_SIZE})")
            return
        
        if len(trip_pool) % MIN_GROUP_SIZE != 0:
            ctx.logger.info(f"‚è≥ Group size not optimal yet")
            return

        ctx.logger.info(f"üéâ Processing {len(trip_pool)} trips...")

        # Perform grouping
        groups = greedy_swap_grouping(trip_pool)
        ctx.logger.info(f"üë• Formed {len(groups)} group(s)")

        for idx, group in enumerate(groups):
            if len(group) < MIN_GROUP_SIZE:
                ctx.logger.info(f"‚ö†Ô∏è  Group {idx + 1} has only {len(group)} members, skipping")
                continue
                
            ctx.logger.info(f"\n{'='*60}\nüèñÔ∏è  PROCESSING GROUP {idx + 1} ({len(group)} members)\n{'='*60}")
            
            # Generate itinerary
            try:
                group_prompt = f"""
                You are an expert travel planner. Generate a combined itinerary for the following travelers:

                {json.dumps(group, indent=2)}

                Create a fun, detailed plan with:
                - Destination overview
                - Daily activities for each day
                - Budget summary
                - Compromise on preferences
                
                Make sure to accommodate all travelers' interests and create a cohesive group experience.
                """

                ctx.logger.info("ü§ñ Calling ASI-1 to generate group itinerary...")
                r = client.chat.completions.create(
                    model="asi1-mini",
                    messages=[
                        {"role": "system", "content": "You are a helpful travel planner AI."},
                        {"role": "user", "content": group_prompt},
                    ],
                )
                itinerary = r.choices[0].message.content

                ctx.logger.info(f"\nüìã GENERATED ITINERARY:\n{itinerary[:200]}...\n")

                # Extract user IDs
                user_ids = [member["user_id"] for member in group]
                
                # Prepare data for Planner Agent
                planner_data = {
                    "group_id": str(uuid4()),
                    "user_ids": user_ids,
                    "itinerary": itinerary,
                    "group_info": {
                        "destination": group[0]["preferences"].get("destination"),
                        "members_count": len(group),
                        "travel_type": group[0]["preferences"].get("travel_type")
                    }
                }
                
                # Send to Planner Agent
                ctx.logger.info(f"üì§ Sending group data to Planner Agent...")
                await ctx.send(PLANNER_ADDRESS, ChatMessage(
                    timestamp=datetime.utcnow(),
                    msg_id=uuid4(),
                    content=[TextContent(type="text", text=json.dumps(planner_data))]
                ))
                ctx.logger.info(f"‚úÖ Sent to Planner: Group {planner_data['group_id']}")

            except Exception as e:
                ctx.logger.exception(f"‚ùå Error processing group {idx + 1}: {e}")

        # Clear trip pool
        ctx.storage.set(TRIP_POOL_KEY, json.dumps([]))
        ctx.logger.info("üßπ Trip pool cleared\n")

    except Exception as e:
        ctx.logger.exception(f"‚ùå Error: {e}")

@protocol.on_message(ChatAcknowledgement)
async def handle_ack(ctx: Context, sender: str, msg: ChatAcknowledgement):
    pass

@agent.on_event("startup")
async def startup(ctx: Context):
    ctx.logger.info("MatchMaker Agent started!")
    ctx.logger.info(f"Agent Address: {agent.address}")
    ctx.logger.info(f"Minimum group size: {MIN_GROUP_SIZE}")

agent.include(protocol, publish_manifest=True)